<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // 1.使用构造函数
    // function Person (name, job) {
    //   this.name = name
    //   this.job = job
    // }
    // var person1 = new Person('leo', 'doctor')
    // var person2 = new Person('Sam', 'teacher')
    // console.log(person1.name, person1.job) // leo doctor
    // console.log(person2.name, person2.job) // Sam teacher

    // // 2.原型模式
    // function Person () {

    // }
    // Person.prototype.name = 'leo'
    // Person.prototype.job = 'doctor'
    // var person1 = new Person()
    // var person2 = new Person()
    // console.log(person1.name, person1.job)
    // console.log(person2.name, person2.job)

    // // 3.组合使用构造函数和原型模式
    //   function Person (name) {
    //     this.name = name
    //   }
    //   Person.prototype.getName = function () {
    //     console.log(this.name)
    //   }
    //   var person1 = new Person('leo')
    //   var person2 = new Person('Sam')
    //   person1.getName() // leo
    //   person2.getName() // Sam

    // // 4. 动态原型模式
    // function Person (name) {
    //   this.name = name
    //   if (typeof this.getName !== 'function') {
    //     Person.prototype.getName = function () {
    //       console.log(this.name)
    //     }
    //   }
    // }
    // var person1 = new Person('leo')
    // person1.getName() // leo

    // // 5.寄生构造函数模式
    // function Person (name) {
    //   var o = new Object()
    //   o.name = name
    //   o.getName = function () {
    //     console.log(this.name)
    //   }
    //   return o
    // }
    // var person1 = new Person('leo')
    // person1.getName()
    // console.log(person1 instanceof Person) // false，这种模式构造函数返回的对象和构造函数外创建的对象一样，所以不能使用instanceof来确定对象类型

    // 5.稳妥构造函数
    function Person (name) {
      var o = new Object()
      o.name = name
      o.getName = function () {
        console.log(name)
      }
      return o
    }
    var person1 = Person('leo')
    person1.getName() // leo, 内部不使用this，创建实例不使用new，这种方式和寄生构造函数一样，不能使用instanceof来判断对象类型
  </script>
</body>
</html>